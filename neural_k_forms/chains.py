"""Functions for operating with and on chains."""

import numpy as np

import torch
import torch.nn as nn


def discretize_chain(chain, d):
    """Discretize a chain.

    Parameters
    ----------
    chain : numpy array
        A chain in R^n, represented as a numpy array of shape (p-1,2,n),
        where p is the number of points in the path.

    d : int
        The number of points in the discretized chain

    Returns
    -------
    numpy array
        A discretized chain in R^n, represented as a numpy array of
        shape (p-1,d,n), where p is the number of points in the path.
    """
    r = chain.shape[0]
    n = chain.shape[2]

    d_chain = torch.zeros((r, d, n))
    t = torch.linspace(0, 1, d)

    for i in range(d):
        d_chain[:, i, :] = (1 - t[i]) * chain[:, 0, :] + t[i] * chain[:, 1, :]

    return d_chain


def generate_integration_matrix(form, chain, d=5):
    """Generate the integration matrix from a chain and a 1-form.

    This is the main entry point for generating an integration matrix,
    containing the integrals of a set of 1-forms along some chains.

    Parameters
    ----------
    form : a Pytorch Sequential object
        The 1-form, i.e. vector field to be applied to the chain. Notice
        that the 1-form results in multiple cochains being represented.

    chain : a torch tensor of shape (r,2,n)
        The chain to be turned into a cochain data matrix.

    d : int
        The number of steps for the discretization of the chain.

    Returns
    -------
    torch.tensor of shape (r,c)
        The integration matrix, with `r` representing the number of
        simplices in the chain, and `c` referring to the number of
        cochains generated by `form`.
    """
    # Discretise chain to ensure that it has `d` points.
    chain = discretize_chain(chain, d)

    # Number of simplices
    r = chain.shape[0]

    # Number of points in the chain
    d = chain.shape[1]

    # Dimension of the ambient space
    n = chain.shape[2]

    # Number of feature cochains that are generated by the 1-form.
    if isinstance(form, nn.Sequential):
        c = int(form[-1].out_features / n)
    else:
        c = form.num_cochains

    # Apply the one-form to the discretized chain. This corresponds to
    # an evaluation of the one-form according to the chain data. After
    # this, we reshape it into the right tensor ensuring sure that the
    # number of cochains `c` has its own dimension.
    out = form(chain).reshape((r, d, n, c))

    # Calculate gradients of the chain along each simplex.
    simplex_grad = chain[:, 1, :] - chain[:, 0, :]

    # Swap dimensions n and c in out
    out = out.permute(0, 1, 3, 2)

    # Calculate the inner product of the one form (i.e. the vector field)
    # and the simplex gradients at all steps on each simplex.
    inner_prod = torch.matmul(out, simplex_grad.T / (d - 1))

    # Take diagonal of out3 along axis 0 and 3 (this corresponds to
    # correcting the broadcasted multiplication effect)
    inner_prod = torch.diagonal(inner_prod, dim1=0, dim2=3)

    # Permute dimensions 0 and 2 of out
    inner_prod = inner_prod.permute(2, 0, 1)

    # Apply the trapezoidal rule to the inner product
    cdm = (inner_prod[:, 1:, :] + inner_prod[:, 0:-1, :]) / 2
    cdm = cdm.sum(axis=1)

    return cdm
